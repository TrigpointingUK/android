


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TrigDetailsOSMapTab</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">uk.trigpointing.android.trigdetails</a>
</div>

<h1>Coverage Summary for Class: TrigDetailsOSMapTab (uk.trigpointing.android.trigdetails)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TrigDetailsOSMapTab</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/46)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/211)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TrigDetailsOSMapTab$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TrigDetailsOSMapTab$MapConfig</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/52)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/228)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package uk.trigpointing.android.trigdetails;
&nbsp;
&nbsp;import java.util.concurrent.CompletableFuture;
&nbsp;import java.util.concurrent.ExecutorService;
&nbsp;import java.util.concurrent.Executors;
&nbsp;import java.util.concurrent.atomic.AtomicInteger;
&nbsp;import java.io.File;
&nbsp;import java.io.FileOutputStream;
&nbsp;import java.io.InputStream;
&nbsp;import java.net.HttpURLConnection;
&nbsp;import java.net.URL;
&nbsp;
&nbsp;import uk.trigpointing.android.common.BaseTabActivity;
&nbsp;import android.content.Intent;
&nbsp;import android.content.SharedPreferences;
&nbsp;import android.database.Cursor;
&nbsp;import android.graphics.Bitmap;
&nbsp;import android.graphics.BitmapFactory;
&nbsp;import android.graphics.Canvas;
&nbsp;import android.graphics.Paint;
&nbsp;import android.os.Bundle;
&nbsp;import android.os.Handler;
&nbsp;import android.os.Looper;
&nbsp;import androidx.preference.PreferenceManager;
&nbsp;import android.util.Log;
&nbsp;
&nbsp;import androidx.recyclerview.widget.RecyclerView;
&nbsp;import androidx.recyclerview.widget.LinearLayoutManager;
&nbsp;import android.widget.Toast;
&nbsp;
&nbsp;import uk.trigpointing.android.DbHelper;
&nbsp;import uk.trigpointing.android.R;
&nbsp;import uk.trigpointing.android.common.DisplayBitmapActivity;
&nbsp;
<b class="nc">&nbsp;public class TrigDetailsOSMapTab extends BaseTabActivity {</b>
&nbsp;	private static final String TAG = &quot;TrigDetailsOSMapTab&quot;;
&nbsp;
&nbsp;	private long mTrigId;
&nbsp;	private DbHelper mDb;
&nbsp;	private String[] mImagePaths;
&nbsp;	private TrigDetailsOSMapAdapter mAdapter;
<b class="nc">&nbsp;	private final AtomicInteger mNextPosition = new AtomicInteger(0);</b>
&nbsp;	private ExecutorService mExecutor;
&nbsp;	private Handler mMainHandler;
&nbsp;	
&nbsp;	// Tile configuration
&nbsp;	private static final int TILE_SIZE = 256;
&nbsp;	private static final int GRID_SIZE = 3; // 3x3 grid
&nbsp;	private static final int FINAL_IMAGE_SIZE = TILE_SIZE * 2; // 2x tile size as requested
&nbsp;	
&nbsp;	// Map configurations: {name, baseUrl, needsApiKey, minZoom, maxZoom, is27700}
<b class="nc">&nbsp;	private static final MapConfig[] MAP_CONFIGS = {</b>
&nbsp;		new MapConfig(&quot;OSM&quot;, &quot;https://tile.openstreetmap.org/{z}/{x}/{y}.png&quot;, false, 8, 12, false),
&nbsp;		new MapConfig(&quot;OS_Outdoor&quot;, &quot;https://api.os.uk/maps/raster/v1/zxy/Outdoor_3857/{z}/{x}/{y}.png&quot;, true, 8, 12, false),
&nbsp;		new MapConfig(&quot;OS_Leisure&quot;, &quot;https://api.os.uk/maps/raster/v1/zxy/Leisure_27700/{z}/{x}/{y}.png&quot;, true, 5, 9, true)
&nbsp;	};
&nbsp;	
&nbsp;	private static class MapConfig {
&nbsp;		final String name;
&nbsp;		final String baseUrl;
&nbsp;		final boolean needsApiKey;
&nbsp;		final int minZoom;
&nbsp;		final int maxZoom;
&nbsp;		final boolean is27700; // Uses British National Grid projection
&nbsp;		
<b class="nc">&nbsp;		MapConfig(String name, String baseUrl, boolean needsApiKey, int minZoom, int maxZoom, boolean is27700) {</b>
<b class="nc">&nbsp;			this.name = name;</b>
<b class="nc">&nbsp;			this.baseUrl = baseUrl;</b>
<b class="nc">&nbsp;			this.needsApiKey = needsApiKey;</b>
<b class="nc">&nbsp;			this.minZoom = minZoom;</b>
<b class="nc">&nbsp;			this.maxZoom = maxZoom;</b>
<b class="nc">&nbsp;			this.is27700 = is27700;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public void onCreate(Bundle savedInstanceState) {
<b class="nc">&nbsp;		super.onCreate(savedInstanceState);</b>
<b class="nc">&nbsp;		setContentView(R.layout.trigosmap);</b>
&nbsp;
&nbsp;		// Initialise threading
<b class="nc">&nbsp;		mExecutor = Executors.newSingleThreadExecutor();</b>
<b class="nc">&nbsp;		mMainHandler = new Handler(Looper.getMainLooper());</b>
&nbsp;
&nbsp;		// get trig_id from extras
<b class="nc">&nbsp;        Bundle extras = getIntent().getExtras();</b>
<b class="nc">&nbsp;		if (extras == null) {return;}</b>
<b class="nc">&nbsp;		mTrigId = extras.getLong(DbHelper.TRIG_ID);</b>
<b class="nc">&nbsp;		Log.i(TAG, &quot;Trig_id = &quot;+mTrigId);</b>
&nbsp;		
&nbsp;		// get trig info from database
<b class="nc">&nbsp;		mDb = new DbHelper(TrigDetailsOSMapTab.this);</b>
<b class="nc">&nbsp;		mDb.open();		</b>
<b class="nc">&nbsp;		Cursor c = mDb.fetchTrigInfo(mTrigId);</b>
<b class="nc">&nbsp;		c.moveToFirst();</b>
&nbsp;		
&nbsp;		// Get coordinates
<b class="nc">&nbsp;		double lat = c.getDouble(c.getColumnIndex(DbHelper.TRIG_LAT));</b>
<b class="nc">&nbsp;		double lon = c.getDouble(c.getColumnIndex(DbHelper.TRIG_LON));</b>
&nbsp;		c.close();
&nbsp;		
<b class="nc">&nbsp;		Log.d(TAG, &quot;Generating cached map images for lat: &quot; + lat + &quot;, lon: &quot; + lon);</b>
&nbsp;		
&nbsp;		// Generate cached images and get file paths
<b class="nc">&nbsp;		generateCachedImages(lat, lon);</b>
&nbsp;	}
&nbsp;	
&nbsp;	private void generateCachedImages(double lat, double lon) {
&nbsp;		// Calculate total expected images
<b class="nc">&nbsp;		int expectedImageCount = 0;</b>
<b class="nc">&nbsp;		for (MapConfig config : MAP_CONFIGS) {</b>
<b class="nc">&nbsp;			for (int zoom = config.minZoom; zoom &lt;= config.maxZoom; zoom += 2) {</b>
<b class="nc">&nbsp;				expectedImageCount++;</b>
&nbsp;			}
&nbsp;		}
&nbsp;		
<b class="nc">&nbsp;		Log.d(TAG, &quot;Expecting &quot; + expectedImageCount + &quot; total images&quot;);</b>
&nbsp;		
&nbsp;		// Create adapter with placeholders immediately and show gallery
<b class="nc">&nbsp;		mAdapter = TrigDetailsOSMapAdapter.createWithPlaceholders(this, expectedImageCount);</b>
<b class="nc">&nbsp;		setupGallery();</b>
&nbsp;		
&nbsp;		// Start generating images progressively
<b class="nc">&nbsp;		for (MapConfig config : MAP_CONFIGS) {</b>
<b class="nc">&nbsp;			for (int zoom = config.minZoom; zoom &lt;= config.maxZoom; zoom += 2) {</b>
&nbsp;				// Create effectively final copies for lambda capture
<b class="nc">&nbsp;				final MapConfig finalConfig = config;</b>
<b class="nc">&nbsp;				final int finalZoom = zoom;</b>
&nbsp;				
<b class="nc">&nbsp;				generateTileBasedImage(mTrigId, lat, lon, finalConfig, finalZoom)</b>
<b class="nc">&nbsp;					.thenAccept(imagePath -&gt; {</b>
<b class="nc">&nbsp;						if (imagePath != null) {</b>
&nbsp;							// Update the next available position
<b class="nc">&nbsp;							int position = mNextPosition.getAndIncrement();</b>
<b class="nc">&nbsp;							mMainHandler.post(() -&gt; {</b>
<b class="nc">&nbsp;								mAdapter.updateImageAtPosition(position, imagePath);</b>
<b class="nc">&nbsp;								int remaining = mAdapter.getPendingCount();</b>
<b class="nc">&nbsp;								Log.d(TAG, &quot;Updated position &quot; + position + &quot;, &quot; + remaining + &quot; images remaining&quot;);</b>
&nbsp;								
<b class="nc">&nbsp;								if (remaining == 0) {</b>
<b class="nc">&nbsp;									Log.d(TAG, &quot;All images loaded!&quot;);</b>
<b class="nc">&nbsp;									Toast.makeText(this, &quot;All map images loaded&quot;, Toast.LENGTH_SHORT).show();</b>
&nbsp;								}
&nbsp;							});
&nbsp;						} else {
<b class="nc">&nbsp;							Log.w(TAG, &quot;Failed to generate image for &quot; + finalConfig.name + &quot; zoom &quot; + finalZoom);</b>
&nbsp;						}
&nbsp;					})
<b class="nc">&nbsp;					.exceptionally(throwable -&gt; {</b>
<b class="nc">&nbsp;						Log.e(TAG, &quot;Error generating image for &quot; + finalConfig.name + &quot; zoom &quot; + finalZoom, throwable);</b>
<b class="nc">&nbsp;						return null;</b>
&nbsp;					});
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;	
&nbsp;	private CompletableFuture&lt;String&gt; generateTileBasedImage(long trigId, double lat, double lon, 
&nbsp;															MapConfig config, int zoom) {
<b class="nc">&nbsp;		return CompletableFuture.supplyAsync(() -&gt; {</b>
&nbsp;			try {
&nbsp;				// Check if cached file already exists
<b class="nc">&nbsp;				String fileName = String.format(&quot;trig_%d_%s_z%d.png&quot;, trigId, config.name, zoom);</b>
<b class="nc">&nbsp;				File cacheDir = new File(getCacheDir(), &quot;map_images&quot;);</b>
<b class="nc">&nbsp;				if (!cacheDir.exists()) {</b>
<b class="nc">&nbsp;					cacheDir.mkdirs();</b>
&nbsp;				}
<b class="nc">&nbsp;				File cachedFile = new File(cacheDir, fileName);</b>
&nbsp;				
<b class="nc">&nbsp;				if (cachedFile.exists()) {</b>
<b class="nc">&nbsp;					Log.d(TAG, &quot;Using cached image: &quot; + fileName);</b>
<b class="nc">&nbsp;					return cachedFile.getAbsolutePath();</b>
&nbsp;				}
&nbsp;				
&nbsp;				// Convert lat/lon to tile coordinates
&nbsp;				int centerX, centerY;
<b class="nc">&nbsp;				if (config.is27700) {</b>
&nbsp;					// For EPSG:27700 (British National Grid), use different conversion
<b class="nc">&nbsp;					centerX = lonToTileX27700(lat, lon, zoom);</b>
<b class="nc">&nbsp;					centerY = latToTileY27700(lat, lon, zoom);</b>
<b class="nc">&nbsp;					Log.d(TAG, String.format(&quot;EPSG:27700 coords for %s zoom %d: lat=%.6f,lon=%.6f -&gt; tile=%d,%d&quot;, </b>
<b class="nc">&nbsp;						config.name, zoom, lat, lon, centerX, centerY));</b>
&nbsp;				} else {
&nbsp;					// For Web Mercator (EPSG:3857)
<b class="nc">&nbsp;					centerX = lonToTileX(lon, zoom);</b>
<b class="nc">&nbsp;					centerY = latToTileY(lat, zoom);</b>
<b class="nc">&nbsp;					Log.d(TAG, String.format(&quot;Web Mercator coords for %s zoom %d: lat=%.6f,lon=%.6f -&gt; tile=%d,%d&quot;, </b>
<b class="nc">&nbsp;						config.name, zoom, lat, lon, centerX, centerY));</b>
&nbsp;				}
&nbsp;				
&nbsp;				// Create 3x3 grid of tiles
<b class="nc">&nbsp;				Bitmap compositeBitmap = Bitmap.createBitmap(</b>
&nbsp;					TILE_SIZE * GRID_SIZE, TILE_SIZE * GRID_SIZE, Bitmap.Config.ARGB_8888);
<b class="nc">&nbsp;				Canvas canvas = new Canvas(compositeBitmap);</b>
&nbsp;				
&nbsp;				// Download and draw each tile
<b class="nc">&nbsp;				for (int dx = -1; dx &lt;= 1; dx++) {</b>
<b class="nc">&nbsp;					for (int dy = -1; dy &lt;= 1; dy++) {</b>
<b class="nc">&nbsp;						int tileX = centerX + dx;</b>
<b class="nc">&nbsp;						int tileY = centerY + dy;</b>
&nbsp;						
<b class="nc">&nbsp;						Bitmap tileBitmap = downloadTile(config, zoom, tileX, tileY);</b>
<b class="nc">&nbsp;						if (tileBitmap != null) {</b>
<b class="nc">&nbsp;							int drawX = (dx + 1) * TILE_SIZE;</b>
<b class="nc">&nbsp;							int drawY = (dy + 1) * TILE_SIZE;</b>
<b class="nc">&nbsp;							canvas.drawBitmap(tileBitmap, drawX, drawY, null);</b>
<b class="nc">&nbsp;							tileBitmap.recycle();</b>
&nbsp;						}
&nbsp;					}
&nbsp;				}
&nbsp;				
&nbsp;				// Calculate the exact pixel position of the trigpoint within the center tile
&nbsp;				double pixelX, pixelY;
<b class="nc">&nbsp;				if (config.is27700) {</b>
<b class="nc">&nbsp;					pixelX = lonToPixelX27700(lat, lon, zoom) - (centerX * TILE_SIZE);</b>
<b class="nc">&nbsp;					pixelY = latToPixelY27700(lat, lon, zoom) - (centerY * TILE_SIZE);</b>
&nbsp;				} else {
<b class="nc">&nbsp;					pixelX = lonToPixelX(lon, zoom) - (centerX * TILE_SIZE);</b>
<b class="nc">&nbsp;					pixelY = latToPixelY(lat, zoom) - (centerY * TILE_SIZE);</b>
&nbsp;				}
&nbsp;				
&nbsp;				// Adjust for the center tile position in our 3x3 grid
<b class="nc">&nbsp;				int centerPixelX = TILE_SIZE + (int)pixelX;</b>
<b class="nc">&nbsp;				int centerPixelY = TILE_SIZE + (int)pixelY;</b>
&nbsp;				
&nbsp;				// Crop to final size (2x tile size) centered on trigpoint
<b class="nc">&nbsp;				int cropLeft = centerPixelX - (FINAL_IMAGE_SIZE / 2);</b>
<b class="nc">&nbsp;				int cropTop = centerPixelY - (FINAL_IMAGE_SIZE / 2);</b>
&nbsp;				
&nbsp;				// Ensure crop area is within bounds
<b class="nc">&nbsp;				cropLeft = Math.max(0, Math.min(cropLeft, compositeBitmap.getWidth() - FINAL_IMAGE_SIZE));</b>
<b class="nc">&nbsp;				cropTop = Math.max(0, Math.min(cropTop, compositeBitmap.getHeight() - FINAL_IMAGE_SIZE));</b>
&nbsp;				
<b class="nc">&nbsp;				Bitmap finalBitmap = Bitmap.createBitmap(compositeBitmap, </b>
&nbsp;					cropLeft, cropTop, FINAL_IMAGE_SIZE, FINAL_IMAGE_SIZE);
<b class="nc">&nbsp;				compositeBitmap.recycle();</b>
&nbsp;				
&nbsp;				// Add blue circle marker at center of image
<b class="nc">&nbsp;				finalBitmap = addCenterMarker(finalBitmap);</b>
&nbsp;				
&nbsp;				// Save to cache
<b class="nc">&nbsp;				try (FileOutputStream out = new FileOutputStream(cachedFile)) {</b>
<b class="nc">&nbsp;					finalBitmap.compress(Bitmap.CompressFormat.PNG, 100, out);</b>
<b class="nc">&nbsp;					finalBitmap.recycle();</b>
<b class="nc">&nbsp;					Log.d(TAG, &quot;Cached new image: &quot; + fileName);</b>
<b class="nc">&nbsp;					return cachedFile.getAbsolutePath();</b>
&nbsp;				}
&nbsp;				
&nbsp;			} catch (Exception e) {
<b class="nc">&nbsp;				Log.e(TAG, &quot;Error generating image for &quot; + config.name + &quot; zoom &quot; + zoom, e);</b>
<b class="nc">&nbsp;				return null;</b>
&nbsp;			}
&nbsp;		}, mExecutor);
&nbsp;	}
&nbsp;	
&nbsp;	private Bitmap downloadTile(MapConfig config, int z, int x, int y) {
&nbsp;		try {
<b class="nc">&nbsp;			String urlString = config.baseUrl</b>
<b class="nc">&nbsp;				.replace(&quot;{z}&quot;, String.valueOf(z))</b>
<b class="nc">&nbsp;				.replace(&quot;{x}&quot;, String.valueOf(x))</b>
<b class="nc">&nbsp;				.replace(&quot;{y}&quot;, String.valueOf(y));</b>
&nbsp;			
<b class="nc">&nbsp;			if (config.needsApiKey) {</b>
<b class="nc">&nbsp;				SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);</b>
<b class="nc">&nbsp;				String apiKey = prefs.getString(&quot;os_api_key&quot;, &quot;&quot;);</b>
<b class="nc">&nbsp;				if (apiKey.isEmpty()) {</b>
<b class="nc">&nbsp;					Log.w(TAG, &quot;No OS API key configured for &quot; + config.name);</b>
<b class="nc">&nbsp;					return null;</b>
&nbsp;				}
<b class="nc">&nbsp;				urlString += &quot;?key=&quot; + apiKey;</b>
&nbsp;			}
&nbsp;			
<b class="nc">&nbsp;			URL url = new URL(urlString);</b>
<b class="nc">&nbsp;			HttpURLConnection connection = (HttpURLConnection) url.openConnection();</b>
<b class="nc">&nbsp;			connection.setConnectTimeout(10000);</b>
<b class="nc">&nbsp;			connection.setReadTimeout(10000);</b>
<b class="nc">&nbsp;			connection.setRequestProperty(&quot;User-Agent&quot;, &quot;TrigpointingUK-Android&quot;);</b>
&nbsp;			
<b class="nc">&nbsp;			try (InputStream is = connection.getInputStream()) {</b>
<b class="nc">&nbsp;				return BitmapFactory.decodeStream(is);</b>
&nbsp;			}
&nbsp;			
&nbsp;		} catch (Exception e) {
<b class="nc">&nbsp;			Log.w(TAG, &quot;Failed to download tile &quot; + z + &quot;/&quot; + x + &quot;/&quot; + y + &quot; from &quot; + config.name, e);</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
&nbsp;	}
&nbsp;	
&nbsp;	// Web Mercator projection helper methods
&nbsp;	private int lonToTileX(double lon, int zoom) {
<b class="nc">&nbsp;		return (int) Math.floor((lon + 180.0) / 360.0 * Math.pow(2.0, zoom));</b>
&nbsp;	}
&nbsp;	
&nbsp;	private int latToTileY(double lat, int zoom) {
<b class="nc">&nbsp;		double latRad = Math.toRadians(lat);</b>
<b class="nc">&nbsp;		return (int) Math.floor((1.0 - asinh(Math.tan(latRad)) / Math.PI) / 2.0 * Math.pow(2.0, zoom));</b>
&nbsp;	}
&nbsp;	
&nbsp;	private double lonToPixelX(double lon, int zoom) {
<b class="nc">&nbsp;		return (lon + 180.0) / 360.0 * Math.pow(2.0, zoom) * TILE_SIZE;</b>
&nbsp;	}
&nbsp;	
&nbsp;	private double latToPixelY(double lat, int zoom) {
<b class="nc">&nbsp;		double latRad = Math.toRadians(lat);</b>
<b class="nc">&nbsp;		return (1.0 - asinh(Math.tan(latRad)) / Math.PI) / 2.0 * Math.pow(2.0, zoom) * TILE_SIZE;</b>
&nbsp;	}
&nbsp;	
&nbsp;	// Manual implementation of asinh for older Java versions
&nbsp;	private double asinh(double x) {
<b class="nc">&nbsp;		return Math.log(x + Math.sqrt(x * x + 1.0));</b>
&nbsp;	}
&nbsp;	
&nbsp;	// EPSG:27700 (British National Grid) coordinate conversion methods
&nbsp;	// Based on Leaflet configuration: resolutions, origin, and bounds
<b class="nc">&nbsp;	private static final double[] OSGB_RESOLUTIONS = {896, 448, 224, 112, 56, 28, 14, 7, 3.5, 1.75, 0.875, 0.4375, 0.21875};</b>
&nbsp;	private static final double OSGB_ORIGIN_X = -238375.0;
&nbsp;	private static final double OSGB_ORIGIN_Y = 1376256.0;
&nbsp;	private static final double OSGB_BOUNDS_MIN_X = -238375.0;
&nbsp;	private static final double OSGB_BOUNDS_MIN_Y = 0.0;
&nbsp;	private static final double OSGB_BOUNDS_MAX_X = 900000.0;
&nbsp;	private static final double OSGB_BOUNDS_MAX_Y = 1376256.0;
&nbsp;	
&nbsp;	private int lonToTileX27700(double lat, double lon, int zoom) {
&nbsp;		// Convert WGS84 lon/lat to OSGB36 easting/northing (simplified transformation)
<b class="nc">&nbsp;		double[] osgb = wgs84ToOsgb36(lat, lon);</b>
<b class="nc">&nbsp;		double easting = osgb[0];</b>
&nbsp;		
&nbsp;		// Use OSGB tile coordinate system
<b class="nc">&nbsp;		if (zoom &gt;= OSGB_RESOLUTIONS.length) zoom = OSGB_RESOLUTIONS.length - 1;</b>
<b class="nc">&nbsp;		double resolution = OSGB_RESOLUTIONS[zoom];</b>
&nbsp;		
<b class="nc">&nbsp;		int tileX = (int) Math.floor((easting - OSGB_ORIGIN_X) / (resolution * TILE_SIZE));</b>
<b class="nc">&nbsp;		return tileX;</b>
&nbsp;	}
&nbsp;	
&nbsp;	private int latToTileY27700(double lat, double lon, int zoom) {
&nbsp;		// Convert WGS84 lon/lat to OSGB36 easting/northing
<b class="nc">&nbsp;		double[] osgb = wgs84ToOsgb36(lat, lon);</b>
<b class="nc">&nbsp;		double northing = osgb[1];</b>
&nbsp;		
&nbsp;		// Use OSGB tile coordinate system  
<b class="nc">&nbsp;		if (zoom &gt;= OSGB_RESOLUTIONS.length) zoom = OSGB_RESOLUTIONS.length - 1;</b>
<b class="nc">&nbsp;		double resolution = OSGB_RESOLUTIONS[zoom];</b>
&nbsp;		
<b class="nc">&nbsp;		int tileY = (int) Math.floor((OSGB_ORIGIN_Y - northing) / (resolution * TILE_SIZE));</b>
<b class="nc">&nbsp;		return tileY;</b>
&nbsp;	}
&nbsp;	
&nbsp;	private double lonToPixelX27700(double lat, double lon, int zoom) {
<b class="nc">&nbsp;		double[] osgb = wgs84ToOsgb36(lat, lon);</b>
<b class="nc">&nbsp;		double easting = osgb[0];</b>
&nbsp;		
<b class="nc">&nbsp;		if (zoom &gt;= OSGB_RESOLUTIONS.length) zoom = OSGB_RESOLUTIONS.length - 1;</b>
<b class="nc">&nbsp;		double resolution = OSGB_RESOLUTIONS[zoom];</b>
&nbsp;		
<b class="nc">&nbsp;		return (easting - OSGB_ORIGIN_X) / resolution;</b>
&nbsp;	}
&nbsp;	
&nbsp;	private double latToPixelY27700(double lat, double lon, int zoom) {
<b class="nc">&nbsp;		double[] osgb = wgs84ToOsgb36(lat, lon);</b>
<b class="nc">&nbsp;		double northing = osgb[1];</b>
&nbsp;		
<b class="nc">&nbsp;		if (zoom &gt;= OSGB_RESOLUTIONS.length) zoom = OSGB_RESOLUTIONS.length - 1;</b>
<b class="nc">&nbsp;		double resolution = OSGB_RESOLUTIONS[zoom];</b>
&nbsp;		
<b class="nc">&nbsp;		return (OSGB_ORIGIN_Y - northing) / resolution;</b>
&nbsp;	}
&nbsp;	
&nbsp;	// Simplified WGS84 to OSGB36 transformation (approximate for UK)
&nbsp;	// Returns [easting, northing] in metres
&nbsp;	private double[] wgs84ToOsgb36(double lat, double lon) {
&nbsp;		// This is a simplified transformation suitable for the UK area
&nbsp;		// For production use, you&#39;d want a proper coordinate transformation library
&nbsp;		
&nbsp;		// Approximate transformation parameters for UK
<b class="nc">&nbsp;		double a = 6377563.396;      // OSGB36 semi-major axis</b>
<b class="nc">&nbsp;		double b = 6356256.909;      // OSGB36 semi-minor axis</b>
<b class="nc">&nbsp;		double f0 = 0.9996012717;    // Scale factor on central meridian</b>
<b class="nc">&nbsp;		double lat0 = Math.toRadians(49);     // Latitude of true origin</b>
<b class="nc">&nbsp;		double lon0 = Math.toRadians(-2);     // Longitude of true origin</b>
<b class="nc">&nbsp;		double N0 = -100000;         // Northing of true origin</b>
<b class="nc">&nbsp;		double E0 = 400000;          // Easting of true origin</b>
&nbsp;		
<b class="nc">&nbsp;		double latRad = Math.toRadians(lat);</b>
<b class="nc">&nbsp;		double lonRad = Math.toRadians(lon);</b>
&nbsp;		
<b class="nc">&nbsp;		double e2 = 1 - (b * b) / (a * a);</b>
<b class="nc">&nbsp;		double n = (a - b) / (a + b);</b>
<b class="nc">&nbsp;		double n2 = n * n;</b>
<b class="nc">&nbsp;		double n3 = n * n * n;</b>
&nbsp;		
<b class="nc">&nbsp;		double cosLat = Math.cos(latRad);</b>
<b class="nc">&nbsp;		double sinLat = Math.sin(latRad);</b>
<b class="nc">&nbsp;		double tanLat = Math.tan(latRad);</b>
&nbsp;		
<b class="nc">&nbsp;		double nu = a * f0 / Math.sqrt(1 - e2 * sinLat * sinLat);</b>
<b class="nc">&nbsp;		double rho = a * f0 * (1 - e2) / Math.pow(1 - e2 * sinLat * sinLat, 1.5);</b>
<b class="nc">&nbsp;		double eta2 = nu / rho - 1;</b>
&nbsp;		
<b class="nc">&nbsp;		double dLon = lonRad - lon0;</b>
<b class="nc">&nbsp;		double dLon2 = dLon * dLon;</b>
<b class="nc">&nbsp;		double dLon3 = dLon2 * dLon;</b>
<b class="nc">&nbsp;		double dLon4 = dLon3 * dLon;</b>
<b class="nc">&nbsp;		double dLon5 = dLon4 * dLon;</b>
<b class="nc">&nbsp;		double dLon6 = dLon5 * dLon;</b>
&nbsp;		
<b class="nc">&nbsp;		double M = b * f0 * ((1 + n + (5/4) * n2 + (5/4) * n3) * (latRad - lat0)</b>
<b class="nc">&nbsp;			- (3 * n + 3 * n2 + (21/8) * n3) * Math.sin(latRad - lat0) * Math.cos(latRad + lat0)</b>
<b class="nc">&nbsp;			+ ((15/8) * n2 + (15/8) * n3) * Math.sin(2 * (latRad - lat0)) * Math.cos(2 * (latRad + lat0))</b>
<b class="nc">&nbsp;			- (35/24) * n3 * Math.sin(3 * (latRad - lat0)) * Math.cos(3 * (latRad + lat0)));</b>
&nbsp;		
<b class="nc">&nbsp;		double I = M + N0;</b>
<b class="nc">&nbsp;		double II = (nu / 2) * sinLat * cosLat;</b>
<b class="nc">&nbsp;		double III = (nu / 24) * sinLat * Math.pow(cosLat, 3) * (5 - tanLat * tanLat + 9 * eta2);</b>
<b class="nc">&nbsp;		double IIIA = (nu / 720) * sinLat * Math.pow(cosLat, 5) * (61 - 58 * tanLat * tanLat + Math.pow(tanLat, 4));</b>
&nbsp;		
<b class="nc">&nbsp;		double IV = nu * cosLat;</b>
<b class="nc">&nbsp;		double V = (nu / 6) * Math.pow(cosLat, 3) * (nu / rho - tanLat * tanLat);</b>
<b class="nc">&nbsp;		double VI = (nu / 120) * Math.pow(cosLat, 5) * (5 - 18 * tanLat * tanLat + Math.pow(tanLat, 4) + 14 * eta2 - 58 * tanLat * tanLat * eta2);</b>
&nbsp;		
<b class="nc">&nbsp;		double northing = I + II * dLon2 + III * dLon4 + IIIA * dLon6;</b>
<b class="nc">&nbsp;		double easting = E0 + IV * dLon + V * dLon3 + VI * dLon5;</b>
&nbsp;		
<b class="nc">&nbsp;		return new double[]{easting, northing};</b>
&nbsp;	}
&nbsp;	
&nbsp;	/**
&nbsp;	 * Adds a small blue circle marker at the center of the image to indicate trigpoint location
&nbsp;	 * @param originalBitmap The bitmap to add the marker to
&nbsp;	 * @return A new bitmap with the blue circle marker added
&nbsp;	 */
&nbsp;	private Bitmap addCenterMarker(Bitmap originalBitmap) {
&nbsp;		// Create a mutable copy of the bitmap
<b class="nc">&nbsp;		Bitmap markedBitmap = originalBitmap.copy(Bitmap.Config.ARGB_8888, true);</b>
&nbsp;		
&nbsp;		// Create canvas to draw on the bitmap
<b class="nc">&nbsp;		Canvas canvas = new Canvas(markedBitmap);</b>
&nbsp;		
&nbsp;		// Calculate circle parameters
<b class="nc">&nbsp;		int imageWidth = markedBitmap.getWidth();</b>
<b class="nc">&nbsp;		int imageHeight = markedBitmap.getHeight();</b>
<b class="nc">&nbsp;		float centerX = imageWidth / 2.0f;</b>
<b class="nc">&nbsp;		float centerY = imageHeight / 2.0f;</b>
<b class="nc">&nbsp;		float circleRadius = imageWidth * 0.025f; // 5% of image width diameter = 2.5% radius</b>
&nbsp;		
&nbsp;		// Create paint for the blue circle outline only
<b class="nc">&nbsp;		Paint circlePaint = new Paint();</b>
<b class="nc">&nbsp;		circlePaint.setColor(0xFF0066CC); // Blue color</b>
<b class="nc">&nbsp;		circlePaint.setStyle(Paint.Style.STROKE);</b>
<b class="nc">&nbsp;		circlePaint.setStrokeWidth(1.5f); // Half the previous thickness (3.0f -&gt; 1.5f)</b>
<b class="nc">&nbsp;		circlePaint.setAntiAlias(true);</b>
&nbsp;		
&nbsp;		// Draw only the outline (no fill for transparent interior)
<b class="nc">&nbsp;		canvas.drawCircle(centerX, centerY, circleRadius, circlePaint);</b>
&nbsp;		
<b class="nc">&nbsp;		Log.d(TAG, String.format(&quot;Added center marker: circle at (%.1f, %.1f) radius %.1f&quot;, </b>
<b class="nc">&nbsp;			centerX, centerY, circleRadius));</b>
&nbsp;		
<b class="nc">&nbsp;		return markedBitmap;</b>
&nbsp;	}
&nbsp;	
&nbsp;	private void setupGallery() {
<b class="nc">&nbsp;		RecyclerView gallery = findViewById(R.id.trigosgallery);</b>
&nbsp;		
&nbsp;		// Use the instance adapter (either newly created or existing)
<b class="nc">&nbsp;		if (mAdapter != null) {</b>
<b class="nc">&nbsp;			gallery.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false));</b>
<b class="nc">&nbsp;			gallery.setAdapter(mAdapter);</b>
&nbsp;		}
&nbsp;		
<b class="nc">&nbsp;		mAdapter.setOnItemClickListener(new TrigDetailsOSMapAdapter.OnItemClickListener() {</b>
&nbsp;			@Override
&nbsp;			public void onItemClick(int position) {
&nbsp;				// Get the current URL from the adapter (may be placeholder or actual image)
<b class="nc">&nbsp;				                                if (mAdapter != null &amp;&amp; position &lt; mAdapter.getItemCount()) {</b>
<b class="nc">&nbsp;					String url = mAdapter.getUrlAtPosition(position);</b>
&nbsp;					
&nbsp;					// Only allow clicks on actual images (not placeholders)
<b class="nc">&nbsp;					if (!&quot;PLACEHOLDER&quot;.equals(url)) {</b>
<b class="nc">&nbsp;						Intent i = new Intent(TrigDetailsOSMapTab.this, DisplayBitmapActivity.class);</b>
<b class="nc">&nbsp;						i.putExtra(&quot;URL&quot;, url);</b>
<b class="nc">&nbsp;						Log.i(TAG, &quot;Clicked OSMap at path: &quot; + url);</b>
<b class="nc">&nbsp;						startActivity(i);</b>
&nbsp;					} else {
<b class="nc">&nbsp;						Log.d(TAG, &quot;Clicked on placeholder at position &quot; + position + &quot; - ignoring&quot;);</b>
<b class="nc">&nbsp;						Toast.makeText(TrigDetailsOSMapTab.this, &quot;Image still loading...&quot;, Toast.LENGTH_SHORT).show();</b>
&nbsp;					}
&nbsp;				}
&nbsp;			}
&nbsp;		});
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void onDestroy() {
<b class="nc">&nbsp;		if (mExecutor != null) {</b>
<b class="nc">&nbsp;			mExecutor.shutdown();</b>
&nbsp;		}
<b class="nc">&nbsp;		if (mDb != null) {</b>
<b class="nc">&nbsp;			mDb.close();</b>
&nbsp;		}
<b class="nc">&nbsp;		super.onDestroy();</b>
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-08-25 13:52</div>
</div>
</body>
</html>
