


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > NearestActivity</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">uk.trigpointing.android.nearest</a>
</div>

<h1>Coverage Summary for Class: NearestActivity (uk.trigpointing.android.nearest)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">NearestActivity</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/129)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/240)
  </span>
</td>
</tr>
  <tr>
    <td class="name">NearestActivity$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NearestActivity$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/35)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/131)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/251)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package uk.trigpointing.android.nearest;
&nbsp;
&nbsp;import android.content.Context;
&nbsp;import android.content.Intent;
&nbsp;import android.content.SharedPreferences;
&nbsp;import android.content.SharedPreferences.Editor;
&nbsp;import android.content.pm.PackageManager;
&nbsp;import android.database.Cursor;
&nbsp;import android.database.SQLException;
&nbsp;import android.hardware.Sensor;
&nbsp;import android.hardware.SensorEvent;
&nbsp;import android.hardware.SensorEventListener;
&nbsp;import android.hardware.SensorManager;
&nbsp;import android.location.Location;
&nbsp;import android.location.LocationListener;
&nbsp;import android.location.LocationManager;
&nbsp;import android.os.Bundle;
&nbsp;import android.os.Handler;
&nbsp;import android.os.Looper;
&nbsp;
&nbsp;import java.util.concurrent.CompletableFuture;
&nbsp;import java.util.concurrent.ExecutorService;
&nbsp;import java.util.concurrent.Executors;
&nbsp;import androidx.preference.PreferenceManager;
&nbsp;import android.util.Log;
&nbsp;import android.net.Uri;
&nbsp;import android.provider.Settings;
&nbsp;import android.view.Display;
&nbsp;import android.view.Menu;
&nbsp;import android.view.MenuItem;
&nbsp;import android.view.View;
&nbsp;import android.view.WindowManager;
&nbsp;import android.widget.ImageView;
&nbsp;import android.widget.ListView;
&nbsp;import android.widget.TextView;
&nbsp;import android.widget.Toast;
&nbsp;import androidx.activity.result.ActivityResultLauncher;
&nbsp;import androidx.activity.result.contract.ActivityResultContracts;
&nbsp;import androidx.core.app.ActivityCompat;
&nbsp;import androidx.core.content.ContextCompat;
&nbsp;import uk.trigpointing.android.DbHelper;
&nbsp;import uk.trigpointing.android.R;
&nbsp;import uk.trigpointing.android.common.BaseActivity;
&nbsp;import uk.trigpointing.android.filter.Filter;
&nbsp;import uk.trigpointing.android.trigdetails.TrigDetailsActivity;
&nbsp;import uk.trigpointing.android.types.LatLon;
&nbsp;
&nbsp;
<b class="nc">&nbsp;public class NearestActivity extends BaseActivity implements SensorEventListener {</b>
&nbsp;	private Cursor 					mCursor;
&nbsp;	private Location 				mCurrentLocation;
<b class="nc">&nbsp;	private double 					mHeading = 0;</b>
&nbsp;	private NearestCursorAdapter 	mListAdapter;
&nbsp;	private DbHelper 				mDb;
<b class="nc">&nbsp;	static int 						mUpdateCount = 0;</b>
<b class="nc">&nbsp;	static int 						mLocationCount = 0;</b>
<b class="nc">&nbsp;	private boolean 				mTaskRunning = false;</b>
&nbsp;	private LocationListener 		mLocationListener;
&nbsp;	private LocationManager 		mLocationManager;
&nbsp;	TextView						mStrLocation;
&nbsp;	TextView						mStrFilter;
&nbsp;	TextView						mNorthText;
&nbsp;	ImageView						mCompassArrow;
&nbsp;	private SharedPreferences       mPrefs;
&nbsp;	private float[] 				mGravity;
&nbsp;	private float[] 				mGeomagnetic;
&nbsp;	private SensorManager 			mSensorManager;
&nbsp;	private Sensor 					accelerometer;
&nbsp;	private Sensor 					magnetometer;
&nbsp;	private int mOrientation;
&nbsp;	private boolean mUsingCompass;
&nbsp;	private static final String     USECOMPASS=&quot;useCompass&quot;;
&nbsp;	private static final String TAG = &quot;NearestActivity&quot;;
&nbsp;	private static final int DETAILS = 1;
&nbsp;    private static final int REQ_LOCATION = 1;
&nbsp;	
&nbsp;	// Modern activity result launcher
&nbsp;	private ActivityResultLauncher&lt;Intent&gt; detailsLauncher;
&nbsp;	
&nbsp;	@Override
&nbsp;	protected void onCreate(Bundle savedInstanceState) {
<b class="nc">&nbsp;		super.onCreate(savedInstanceState);		</b>
<b class="nc">&nbsp;		setContentView(R.layout.triglist);</b>
&nbsp;		
&nbsp;		// Enable back button in action bar
<b class="nc">&nbsp;		if (getSupportActionBar() != null) {</b>
<b class="nc">&nbsp;			getSupportActionBar().setDisplayHomeAsUpEnabled(true);</b>
<b class="nc">&nbsp;			getSupportActionBar().setTitle(&quot;Nearest Trig Points&quot;);</b>
&nbsp;		}
&nbsp;
&nbsp;		// Register activity result launcher for modern navigation
<b class="nc">&nbsp;		detailsLauncher = registerForActivityResult(</b>
&nbsp;			new ActivityResultContracts.StartActivityForResult(),
&nbsp;			result -&gt; {
<b class="nc">&nbsp;				Log.i(TAG, &quot;onActivityResult&quot;);</b>
<b class="nc">&nbsp;				refreshList();</b>
<b class="nc">&nbsp;				updateFilterHeader();</b>
&nbsp;			}
&nbsp;		);
&nbsp;
&nbsp;		// find view references
<b class="nc">&nbsp;		mStrLocation 			= findViewById(R.id.trigListLocation);</b>
&nbsp;		
&nbsp;		// Content positioning is now handled by BaseActivity
<b class="nc">&nbsp;		mStrFilter	 			= findViewById(R.id.trigListHeader);</b>
<b class="nc">&nbsp;		mNorthText	 			= findViewById(R.id.north);</b>
<b class="nc">&nbsp;		mCompassArrow			= findViewById(R.id.compassArrow);</b>
&nbsp;		
&nbsp;		// Set up compass area click handler
<b class="nc">&nbsp;		findViewById(R.id.compassArea).setOnClickListener(v -&gt; {</b>
<b class="nc">&nbsp;			useCompass(!mUsingCompass);</b>
&nbsp;		});
&nbsp;		
&nbsp;		// Set up trigpoint types filter click handler
<b class="nc">&nbsp;		mStrFilter.setOnClickListener(v -&gt; {</b>
<b class="nc">&nbsp;			Intent i = new Intent(NearestActivity.this, uk.trigpointing.android.filter.TrigpointTypesActivity.class);</b>
<b class="nc">&nbsp;			detailsLauncher.launch(i);</b>
&nbsp;		});
&nbsp;		
<b class="nc">&nbsp;		mPrefs = PreferenceManager.getDefaultSharedPreferences(this);</b>
&nbsp;		
&nbsp;		// create various objects
&nbsp;		try {
<b class="nc">&nbsp;			mDb = new DbHelper(NearestActivity.this);</b>
<b class="nc">&nbsp;			mDb.open();</b>
&nbsp;		} catch (SQLException e) {
<b class="nc">&nbsp;			e.printStackTrace();</b>
<b class="nc">&nbsp;			Toast.makeText(this, &quot;Error opening database.  Please try again shortly.&quot;, Toast.LENGTH_SHORT).show();</b>
<b class="nc">&nbsp;			finish();</b>
&nbsp;		}
&nbsp;		
&nbsp;		// Set up ListView since we&#39;re no longer using ListActivity
<b class="nc">&nbsp;		ListView listView = findViewById(android.R.id.list);</b>
<b class="nc">&nbsp;		if (listView != null) {</b>
<b class="nc">&nbsp;			listView.setOnItemClickListener(new android.widget.AdapterView.OnItemClickListener() {</b>
&nbsp;				@Override
&nbsp;				public void onItemClick(android.widget.AdapterView&lt;?&gt; parent, View view, int position, long id) {
<b class="nc">&nbsp;					onListItemClick((ListView) parent, view, position, id);</b>
&nbsp;				}
&nbsp;			});
&nbsp;		}
&nbsp;	
&nbsp;		// Start off with no location + no trigs
<b class="nc">&nbsp;		mListAdapter = new NearestCursorAdapter(this, R.layout.trigrow, null, new String[]{}, new int[]{}, null);</b>
<b class="nc">&nbsp;						ListView listViewAdapter = findViewById(android.R.id.list);</b>
<b class="nc">&nbsp;				if (listViewAdapter != null) {</b>
<b class="nc">&nbsp;					listViewAdapter.setAdapter(mListAdapter);</b>
&nbsp;				}
&nbsp;
&nbsp;		// Find a cached location
<b class="nc">&nbsp;		mLocationManager = (LocationManager) this.getSystemService(Context.LOCATION_SERVICE);</b>
&nbsp;
&nbsp;		// Initialize sensors early so onResume/useCompass never sees nulls even if we return early
<b class="nc">&nbsp;		mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);</b>
<b class="nc">&nbsp;		accelerometer = mSensorManager != null ? mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER) : null;</b>
<b class="nc">&nbsp;		magnetometer = mSensorManager != null ? mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD) : null;</b>
&nbsp;		
&nbsp;		// Define a listener that responds to location updates (init early so it&#39;s never null)
<b class="nc">&nbsp;		mLocationListener = new LocationListener() {</b>
&nbsp;			public void onLocationChanged(Location location) {
<b class="nc">&nbsp;				mLocationCount++;</b>
<b class="nc">&nbsp;				updateLocationHeader(&quot;listener&quot;);</b>
<b class="nc">&nbsp;				if (isBetterLocation(location, mCurrentLocation)) {</b>
<b class="nc">&nbsp;					mCurrentLocation = location;</b>
<b class="nc">&nbsp;					refreshList();</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			public void onStatusChanged(String provider, int status, Bundle extras) {}</b>
<b class="nc">&nbsp;			public void onProviderEnabled(String provider) {}</b>
<b class="nc">&nbsp;			public void onProviderDisabled(String provider) {}</b>
&nbsp;		};
&nbsp;		
&nbsp;		// Check for location permissions
<b class="nc">&nbsp;		if (checkSelfPermission(android.Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &amp;&amp;</b>
<b class="nc">&nbsp;			checkSelfPermission(android.Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {</b>
&nbsp;			// Request location permissions
<b class="nc">&nbsp;			requestPermissions(new String[]{</b>
&nbsp;				android.Manifest.permission.ACCESS_FINE_LOCATION,
&nbsp;				android.Manifest.permission.ACCESS_COARSE_LOCATION
&nbsp;			}, REQ_LOCATION);
<b class="nc">&nbsp;			updateLocationHeader(&quot;permission_required&quot;);</b>
&nbsp;			return;
&nbsp;		} else {
&nbsp;			// We have permission, proceed with location access
&nbsp;			// Try to get last known location from available providers
<b class="nc">&nbsp;			mCurrentLocation = getLastKnownLocationFromAvailableProviders();</b>
<b class="nc">&nbsp;			updateLocationHeader(&quot;cached&quot;);</b>
<b class="nc">&nbsp;			if (mCurrentLocation != null &amp;&amp; !mTaskRunning) {findTrigs();}</b>
&nbsp;		}
&nbsp;		
&nbsp;
&nbsp;		// Sensors already initialized above
&nbsp;		
&nbsp;		// Is the screen rotated? (using modern API instead of deprecated getDefaultDisplay/getOrientation)
<b class="nc">&nbsp;		WindowManager windowManager = (WindowManager) getSystemService(WINDOW_SERVICE);</b>
&nbsp;		// Use modern rotation detection
<b class="nc">&nbsp;		mOrientation = getResources().getConfiguration().orientation;</b>
&nbsp;		
<b class="nc">&nbsp;		Log.i(TAG, &quot;getOrientation(): &quot; + mOrientation);</b>
<b class="nc">&nbsp;		mListAdapter.setOrientation(mOrientation);</b>
&nbsp;		 
&nbsp;	}
&nbsp;
&nbsp;
&nbsp;	
&nbsp;
&nbsp;	
&nbsp;	@Override
&nbsp;	protected void onPause() {
&nbsp;		// save compass preference
<b class="nc">&nbsp;		Editor editor = mPrefs.edit();</b>
<b class="nc">&nbsp;		editor.putBoolean(USECOMPASS, mUsingCompass);</b>
<b class="nc">&nbsp;		editor.apply();</b>
&nbsp;		// stop listening to the GPS and compass
&nbsp;		try {
<b class="nc">&nbsp;			if (mLocationManager != null &amp;&amp; (</b>
<b class="nc">&nbsp;					checkSelfPermission(android.Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED ||</b>
<b class="nc">&nbsp;					checkSelfPermission(android.Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED)) {</b>
<b class="nc">&nbsp;				mLocationManager.removeUpdates(mLocationListener);</b>
&nbsp;			}
&nbsp;		} catch (SecurityException ignore) {
&nbsp;			// If we do not have permission yet, ignore
&nbsp;		}
<b class="nc">&nbsp;		useCompass(false);</b>
<b class="nc">&nbsp;		super.onPause();</b>
&nbsp;	}
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;	@Override
&nbsp;	protected void onResume() {
<b class="nc">&nbsp;		super.onResume();</b>
&nbsp;		// Register the listener with the Location Manager to receive location updates
<b class="nc">&nbsp;		if (checkSelfPermission(android.Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED ||</b>
<b class="nc">&nbsp;			checkSelfPermission(android.Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED) {</b>
&nbsp;			// Request location updates from available providers only
<b class="nc">&nbsp;			requestLocationUpdatesFromAvailableProviders();</b>
&nbsp;		}
&nbsp;		else {
&nbsp;			// If returning here after a permission denial, ensure headers/UI reflect state
<b class="nc">&nbsp;			updateLocationHeader(&quot;permission_required&quot;);</b>
&nbsp;		}
&nbsp;		// Decide whether to use the compass
<b class="nc">&nbsp;		useCompass(mPrefs.getBoolean(USECOMPASS, false));</b>
&nbsp;		// Setup header icons
<b class="nc">&nbsp;		updateFilterHeader();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Safely get last known location from available providers
&nbsp;	 * Network provider was deprecated and removed in newer Android versions
&nbsp;	 */
&nbsp;	private Location getLastKnownLocationFromAvailableProviders() {
<b class="nc">&nbsp;		Location bestLocation = null;</b>
&nbsp;		
&nbsp;		try {
&nbsp;			// Try GPS provider first (most accurate)
<b class="nc">&nbsp;			if (mLocationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)) {</b>
<b class="nc">&nbsp;				Location gpsLocation = mLocationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);</b>
<b class="nc">&nbsp;				if (isBetterLocation(gpsLocation, bestLocation)) {</b>
<b class="nc">&nbsp;					bestLocation = gpsLocation;</b>
&nbsp;				}
&nbsp;			}
&nbsp;			
&nbsp;			// Try network provider only if it exists (deprecated/removed on newer devices)
&nbsp;			try {
<b class="nc">&nbsp;				if (mLocationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER)) {</b>
<b class="nc">&nbsp;					Location networkLocation = mLocationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER);</b>
<b class="nc">&nbsp;					if (isBetterLocation(networkLocation, bestLocation)) {</b>
<b class="nc">&nbsp;						bestLocation = networkLocation;</b>
&nbsp;					}
&nbsp;				}
&nbsp;			} catch (IllegalArgumentException e) {
&nbsp;				// Network provider doesn&#39;t exist on this device - this is expected on newer Android versions
<b class="nc">&nbsp;				Log.d(TAG, &quot;Network provider not available (this is normal on newer Android versions)&quot;);</b>
&nbsp;			}
&nbsp;			
&nbsp;			// Try passive provider as fallback
&nbsp;			try {
<b class="nc">&nbsp;				if (mLocationManager.isProviderEnabled(LocationManager.PASSIVE_PROVIDER)) {</b>
<b class="nc">&nbsp;					Location passiveLocation = mLocationManager.getLastKnownLocation(LocationManager.PASSIVE_PROVIDER);</b>
<b class="nc">&nbsp;					if (isBetterLocation(passiveLocation, bestLocation)) {</b>
<b class="nc">&nbsp;						bestLocation = passiveLocation;</b>
&nbsp;					}
&nbsp;				}
&nbsp;			} catch (IllegalArgumentException e) {
<b class="nc">&nbsp;				Log.d(TAG, &quot;Passive provider not available&quot;);</b>
&nbsp;			}
&nbsp;			
&nbsp;		} catch (SecurityException e) {
<b class="nc">&nbsp;			Log.w(TAG, &quot;No location permission for getLastKnownLocation&quot;);</b>
&nbsp;		} catch (Exception e) {
<b class="nc">&nbsp;			Log.e(TAG, &quot;Error getting last known location&quot;, e);</b>
&nbsp;		}
&nbsp;		
<b class="nc">&nbsp;		return bestLocation;</b>
&nbsp;	}
&nbsp;	
&nbsp;	/**
&nbsp;	 * Safely request location updates from available providers
&nbsp;	 */
&nbsp;	private void requestLocationUpdatesFromAvailableProviders() {
&nbsp;		try {
&nbsp;			// Always try GPS provider (most accurate, available on all devices)
<b class="nc">&nbsp;			if (mLocationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)) {</b>
<b class="nc">&nbsp;				mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 1000*300, 250, mLocationListener);</b>
<b class="nc">&nbsp;				Log.d(TAG, &quot;Requested location updates from GPS provider&quot;);</b>
&nbsp;			}
&nbsp;			
&nbsp;			// Try network provider only if it exists (deprecated/removed on newer devices)
&nbsp;			try {
<b class="nc">&nbsp;				if (mLocationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER)) {</b>
<b class="nc">&nbsp;					mLocationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 1000*30, 250, mLocationListener);</b>
<b class="nc">&nbsp;					Log.d(TAG, &quot;Requested location updates from network provider&quot;);</b>
&nbsp;				}
&nbsp;			} catch (IllegalArgumentException e) {
&nbsp;				// Network provider doesn&#39;t exist on this device - this is expected on newer Android versions
<b class="nc">&nbsp;				Log.d(TAG, &quot;Network provider not available for location updates (this is normal on newer Android versions)&quot;);</b>
&nbsp;			}
&nbsp;			
&nbsp;		} catch (SecurityException e) {
<b class="nc">&nbsp;			Log.w(TAG, &quot;No location permission for requestLocationUpdates&quot;);</b>
&nbsp;		} catch (Exception e) {
<b class="nc">&nbsp;			Log.e(TAG, &quot;Error requesting location updates&quot;, e);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void useCompass(boolean use) {
<b class="nc">&nbsp;		mUsingCompass = use;</b>
<b class="nc">&nbsp;		mListAdapter.setUsingCompass(use);</b>
<b class="nc">&nbsp;		if (mUsingCompass) {</b>
<b class="nc">&nbsp;			mSensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_NORMAL);</b>
<b class="nc">&nbsp;		    mSensorManager.registerListener(this, magnetometer, SensorManager.SENSOR_DELAY_NORMAL);</b>
<b class="nc">&nbsp;		    					mNorthText.setTextColor(ContextCompat.getColor(this, R.color.compassEnabled));</b>
&nbsp;	    } else {
<b class="nc">&nbsp;		    mSensorManager.unregisterListener(this);</b>
<b class="nc">&nbsp;		    mHeading = 0;</b>
<b class="nc">&nbsp;		    mCompassArrow.setImageResource(mListAdapter.getArrow(0));</b>
<b class="nc">&nbsp;		    					mNorthText.setTextColor(ContextCompat.getColor(this, R.color.compassDisabled));</b>
<b class="nc">&nbsp;        	mListAdapter.setHeading(0);</b>
<b class="nc">&nbsp;        	mListAdapter.notifyDataSetChanged();</b>
&nbsp;		}
&nbsp;	}
&nbsp;	
&nbsp;
&nbsp;
&nbsp;	private void refreshList() {
<b class="nc">&nbsp;		if (!mTaskRunning) {findTrigs();}</b>
&nbsp;	}
&nbsp;	
&nbsp;	
&nbsp;	private void updateLocationHeader(String comment) {
&nbsp;		
<b class="nc">&nbsp;		if (null != mCurrentLocation) {</b>
<b class="nc">&nbsp;			LatLon ll = new LatLon(mCurrentLocation);</b>
<b class="nc">&nbsp;			mStrLocation.setText(String.format(&quot;Near to %s   (from %s)&quot; </b>
<b class="nc">&nbsp;					, mCurrentLocation.getProvider().equals(&quot;gps&quot;) ? ll.getOSGB10() : ll.getOSGB6()</b>
<b class="nc">&nbsp;					, mCurrentLocation.getProvider()</b>
&nbsp;			));
<b class="nc">&nbsp;			Log.d(TAG, &quot;Location update count : &quot; + mUpdateCount + &quot; Location count : &quot; + mLocationCount + &quot; &quot; + comment);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			mStrLocation.setText(&quot;Location is unknown&quot;);</b>
<b class="nc">&nbsp;			Log.d(TAG, &quot;Location unknown : &quot; + mUpdateCount + &quot; Location count : &quot; + mLocationCount + &quot; &quot; + comment);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void updateFilterHeader() {
&nbsp;		// Get trigpoint type text
<b class="nc">&nbsp;		int filterType = mPrefs.getInt(Filter.FILTERTYPE, 0);</b>
<b class="nc">&nbsp;		String typeText = getTypeTextFromIndex(filterType);</b>
&nbsp;		
&nbsp;		// Get logging status text
<b class="nc">&nbsp;		String statusText = mPrefs.getString(Filter.FILTERRADIOTEXT, &quot;Logged or not&quot;);</b>
&nbsp;		
&nbsp;		// Create two-line display
<b class="nc">&nbsp;		String headerText = typeText + &quot;\n&quot; + statusText;</b>
<b class="nc">&nbsp;		mStrFilter.setText(headerText);</b>
&nbsp;	}
&nbsp;	
&nbsp;	private String getTypeTextFromIndex(int filterType) {
<b class="nc">&nbsp;		switch (filterType) {</b>
<b class="nc">&nbsp;			case 0: return &quot;Pillars Only&quot;;</b>
<b class="nc">&nbsp;			case 1: return &quot;Pillars + FBM&quot;;</b>
<b class="nc">&nbsp;			case 2: return &quot;FBM Only&quot;;</b>
<b class="nc">&nbsp;			case 3: return &quot;Passive Stations&quot;;</b>
<b class="nc">&nbsp;			case 4: return &quot;Intersected Stations&quot;;</b>
<b class="nc">&nbsp;			case 5: return &quot;All except Intersected&quot;;</b>
<b class="nc">&nbsp;			case 6: return &quot;All Types&quot;;</b>
<b class="nc">&nbsp;			default: return &quot;All Types&quot;;</b>
&nbsp;		}
&nbsp;	}
&nbsp;	
&nbsp;	@Override
&nbsp;    public boolean onCreateOptionsMenu(Menu menu) {
<b class="nc">&nbsp;        boolean result = super.onCreateOptionsMenu(menu);</b>
<b class="nc">&nbsp;		getMenuInflater().inflate(R.menu.nearestmenu, menu);</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }    
&nbsp;    
&nbsp;    
&nbsp;	@Override
&nbsp;	public boolean onOptionsItemSelected(MenuItem item) {
<b class="nc">&nbsp;		int itemId = item.getItemId();</b>
&nbsp;		
<b class="nc">&nbsp;		if (itemId == android.R.id.home) {</b>
&nbsp;			// Handle back button in action bar
<b class="nc">&nbsp;			finish();</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;		}
<b class="nc">&nbsp;		return super.onOptionsItemSelected(item);</b>
&nbsp;	}
&nbsp;        
&nbsp;	@Override
&nbsp;	protected void onDestroy() {
&nbsp;		try {
<b class="nc">&nbsp;			mDb.close();</b>
&nbsp;		} catch (Exception e) {
<b class="nc">&nbsp;			e.printStackTrace();</b>
&nbsp;		}
<b class="nc">&nbsp;		super.onDestroy();</b>
&nbsp;	}
&nbsp;
&nbsp;    public void onListItemClick(ListView l, View v, int position, long id) {
<b class="nc">&nbsp;        Intent i = new Intent(this, TrigDetailsActivity.class);</b>
<b class="nc">&nbsp;        i.putExtra(DbHelper.TRIG_ID, id);</b>
<b class="nc">&nbsp;        Log.i(TAG, &quot;Trig_id = &quot; +id);</b>
<b class="nc">&nbsp;        detailsLauncher.launch(i);</b>
&nbsp;    }
&nbsp;	
&nbsp;	
&nbsp;    
&nbsp;	
&nbsp;
&nbsp;	
&nbsp;	@Override
&nbsp;	public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
<b class="nc">&nbsp;		super.onRequestPermissionsResult(requestCode, permissions, grantResults);</b>
<b class="nc">&nbsp;		if (requestCode == REQ_LOCATION) {</b>
<b class="nc">&nbsp;			boolean granted = false;</b>
<b class="nc">&nbsp;			if (grantResults != null &amp;&amp; grantResults.length &gt; 0) {</b>
<b class="nc">&nbsp;				for (int res : grantResults) {</b>
<b class="nc">&nbsp;					if (res == PackageManager.PERMISSION_GRANTED) {</b>
<b class="nc">&nbsp;						granted = true;</b>
&nbsp;						break;
&nbsp;					}
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			if (granted) {</b>
&nbsp;				// Check permissions explicitly before calling getLastKnownLocation
<b class="nc">&nbsp;				if (ActivityCompat.checkSelfPermission(this, android.Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED ||</b>
<b class="nc">&nbsp;					ActivityCompat.checkSelfPermission(this, android.Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED) {</b>
&nbsp;					// Try to get last known location from available providers
<b class="nc">&nbsp;					mCurrentLocation = getLastKnownLocationFromAvailableProviders();</b>
<b class="nc">&nbsp;					updateLocationHeader(&quot;cached&quot;);</b>
<b class="nc">&nbsp;					if (mCurrentLocation != null &amp;&amp; !mTaskRunning) {findTrigs();}</b>
&nbsp;				}
&nbsp;			} else {
<b class="nc">&nbsp;				boolean showRationaleFine = shouldShowRequestPermissionRationale(android.Manifest.permission.ACCESS_FINE_LOCATION);</b>
<b class="nc">&nbsp;				boolean showRationaleCoarse = shouldShowRequestPermissionRationale(android.Manifest.permission.ACCESS_COARSE_LOCATION);</b>
<b class="nc">&nbsp;				if (showRationaleFine || showRationaleCoarse) {</b>
<b class="nc">&nbsp;					new androidx.appcompat.app.AlertDialog.Builder(this)</b>
<b class="nc">&nbsp;							.setTitle(&quot;Location permission required&quot;)</b>
<b class="nc">&nbsp;							.setMessage(&quot;This feature needs your location to find nearby trig points.&quot;)</b>
<b class="nc">&nbsp;							.setPositiveButton(&quot;Try again&quot;, (d, which) -&gt; requestPermissions(new String[]{</b>
&nbsp;									android.Manifest.permission.ACCESS_FINE_LOCATION,
&nbsp;									android.Manifest.permission.ACCESS_COARSE_LOCATION
&nbsp;							}, REQ_LOCATION))
<b class="nc">&nbsp;							.setNegativeButton(&quot;Cancel&quot;, (d, w) -&gt; Toast.makeText(this, &quot;Location permission denied&quot;, Toast.LENGTH_SHORT).show())</b>
<b class="nc">&nbsp;							.show();</b>
&nbsp;				} else {
<b class="nc">&nbsp;					new androidx.appcompat.app.AlertDialog.Builder(this)</b>
<b class="nc">&nbsp;							.setTitle(&quot;Enable location in Settings&quot;)</b>
<b class="nc">&nbsp;							.setMessage(&quot;Permission was permanently denied. Open App Settings to enable it.&quot;)</b>
<b class="nc">&nbsp;							.setPositiveButton(&quot;Open Settings&quot;, (d, which) -&gt; openAppSettings())</b>
<b class="nc">&nbsp;							.setNegativeButton(&quot;Cancel&quot;, (d, w) -&gt; Toast.makeText(this, &quot;Location permission denied&quot;, Toast.LENGTH_SHORT).show())</b>
<b class="nc">&nbsp;							.show();</b>
&nbsp;				}
<b class="nc">&nbsp;				updateLocationHeader(&quot;permission_denied&quot;);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void openAppSettings() {
<b class="nc">&nbsp;		Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);</b>
<b class="nc">&nbsp;		Uri uri = Uri.fromParts(&quot;package&quot;, getPackageName(), null);</b>
<b class="nc">&nbsp;		intent.setData(uri);</b>
<b class="nc">&nbsp;		startActivity(intent);</b>
&nbsp;	}
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;	private void findTrigs() {
<b class="nc">&nbsp;		Log.i(TAG, &quot;FindTrigsTask.onPreExecute&quot;);</b>
<b class="nc">&nbsp;		mTaskRunning = true;</b>
&nbsp;		
<b class="nc">&nbsp;		ExecutorService executor = Executors.newSingleThreadExecutor();</b>
<b class="nc">&nbsp;		Handler mainHandler = new Handler(Looper.getMainLooper());</b>
&nbsp;		
<b class="nc">&nbsp;		CompletableFuture.supplyAsync(() -&gt; {</b>
<b class="nc">&nbsp;			Log.i(TAG, &quot;FindTrigsTask.doInBackground&quot;);</b>
<b class="nc">&nbsp;			Cursor c = null;</b>
&nbsp;			try {
<b class="nc">&nbsp;				c = mDb.fetchTrigList(mCurrentLocation);</b>
&nbsp;				// startManagingCursor is deprecated - cursor will be managed manually
&nbsp;			} catch (Exception e) {
<b class="nc">&nbsp;				e.printStackTrace();</b>
&nbsp;			}
<b class="nc">&nbsp;			mUpdateCount++;</b>
<b class="nc">&nbsp;			return c;</b>
&nbsp;		}, executor)
<b class="nc">&nbsp;		.thenAcceptAsync(cursor -&gt; {</b>
<b class="nc">&nbsp;			Log.i(TAG, &quot;FindTrigsTask.onPostExecute &quot; + cursor);</b>
&nbsp;			try {
<b class="nc">&nbsp;				mCursor = cursor;</b>
<b class="nc">&nbsp;				mListAdapter.swapCursor(mCursor, mCurrentLocation);</b>
&nbsp;			} catch (Exception e) {
<b class="nc">&nbsp;				e.printStackTrace();</b>
<b class="nc">&nbsp;				mListAdapter.swapCursor(null, mCurrentLocation);</b>
&nbsp;			}
<b class="nc">&nbsp;			updateLocationHeader(&quot;task&quot;);</b>
<b class="nc">&nbsp;			mTaskRunning = false;</b>
<b class="nc">&nbsp;		}, mainHandler::post);</b>
&nbsp;	}
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;	/** Determines whether one Location reading is better than the current Location fix
&nbsp;	 * @param location  The new Location that you want to evaluate
&nbsp;	 * @param currentBestLocation  The current Location fix, to which you want to compare the new one
&nbsp;	 */
&nbsp;	private static final int TWO_MINUTES = 1000 * 60 * 2;
&nbsp;	protected boolean isBetterLocation(Location location, Location currentBestLocation) {
<b class="nc">&nbsp;		if (currentBestLocation == null) {</b>
&nbsp;			// A new location is always better than no location
<b class="nc">&nbsp;			return true;</b>
&nbsp;		}
&nbsp;		
<b class="nc">&nbsp;		if (location == null) {</b>
&nbsp;			// A null location is never better than anything
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
&nbsp;		// Check whether the new location fix is newer or older
<b class="nc">&nbsp;		long timeDelta = location.getTime() - currentBestLocation.getTime();</b>
<b class="nc">&nbsp;		boolean isSignificantlyNewer = timeDelta &gt; TWO_MINUTES;</b>
<b class="nc">&nbsp;		boolean isSignificantlyOlder = timeDelta &lt; -TWO_MINUTES;</b>
<b class="nc">&nbsp;		boolean isNewer = timeDelta &gt; 0;</b>
&nbsp;
&nbsp;		// If it&#39;s been more than two minutes since the current location, use the new location
&nbsp;		// because the user has likely moved
<b class="nc">&nbsp;		if (isSignificantlyNewer) {</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;			// If the new location is more than two minutes older, it must be worse
<b class="nc">&nbsp;		} else if (isSignificantlyOlder) {</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
&nbsp;		// Check whether the new location fix is more or less accurate
<b class="nc">&nbsp;		int accuracyDelta = (int) (location.getAccuracy() - currentBestLocation.getAccuracy());</b>
<b class="nc">&nbsp;		boolean isLessAccurate = accuracyDelta &gt; 0;</b>
<b class="nc">&nbsp;		boolean isMoreAccurate = accuracyDelta &lt; 0;</b>
<b class="nc">&nbsp;		boolean isSignificantlyLessAccurate = accuracyDelta &gt; 200;</b>
&nbsp;
&nbsp;		// Check if the old and new location are from the same provider
<b class="nc">&nbsp;		boolean isFromSameProvider = isSameProvider(location.getProvider(),</b>
<b class="nc">&nbsp;				currentBestLocation.getProvider());</b>
&nbsp;
&nbsp;		// Determine location quality using a combination of timeliness and accuracy
<b class="nc">&nbsp;		if (isMoreAccurate) {</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		} else if (isNewer &amp;&amp; !isLessAccurate) {</b>
<b class="nc">&nbsp;			return true;</b>
<b class="nc">&nbsp;		} else return isNewer &amp;&amp; !isSignificantlyLessAccurate &amp;&amp; isFromSameProvider;</b>
&nbsp;    }
&nbsp;
&nbsp;	/** Checks whether two providers are the same */
&nbsp;	private boolean isSameProvider(String provider1, String provider2) {
<b class="nc">&nbsp;		if (provider1 == null) {</b>
<b class="nc">&nbsp;			return provider2 == null;</b>
&nbsp;		}
<b class="nc">&nbsp;		return provider1.equals(provider2);</b>
&nbsp;	}
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;	// handle compass events
&nbsp;	@Override
<b class="nc">&nbsp;	public void onAccuracyChanged(Sensor sensor, int accuracy) {}	</b>
&nbsp;	@Override
&nbsp;	public void onSensorChanged(SensorEvent event) {
<b class="nc">&nbsp;		switch (event.sensor.getType()) {</b>
&nbsp;		case Sensor.TYPE_ACCELEROMETER:
<b class="nc">&nbsp;			mGravity = event.values;</b>
&nbsp;			break;
&nbsp;		case Sensor.TYPE_MAGNETIC_FIELD:
<b class="nc">&nbsp;	        mGeomagnetic = event.values;</b>
&nbsp;	        break;
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (!mUsingCompass) {return;}</b>
&nbsp;		
<b class="nc">&nbsp;		if (mGravity != null &amp;&amp; mGeomagnetic != null) {</b>
<b class="nc">&nbsp;	    	float[] R = new float[9];</b>
<b class="nc">&nbsp;	        float[] I = new float[9];</b>
<b class="nc">&nbsp;	        boolean success = SensorManager.getRotationMatrix(R, I, mGravity, mGeomagnetic);</b>
<b class="nc">&nbsp;	        if (success) {</b>
<b class="nc">&nbsp;	        	float[] orientation = new float[3];</b>
<b class="nc">&nbsp;	        	SensorManager.getOrientation(R, orientation);</b>
<b class="nc">&nbsp;	        	mHeading = orientation[0] * 180.0/Math.PI; // orientation contains: azimuth[0], pitch[1] and roll[2]</b>
&nbsp;	        	//Log.d(TAG, &quot;Heading = &quot; + mHeading);
<b class="nc">&nbsp;	        	mListAdapter.setHeading(mHeading);</b>
<b class="nc">&nbsp;				mListAdapter.notifyDataSetChanged();</b>
<b class="nc">&nbsp;				mCompassArrow.setImageResource(mListAdapter.getArrow(-mHeading));</b>
&nbsp;	        }
&nbsp;	    }
&nbsp;	}
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-08-25 13:52</div>
</div>
</body>
</html>
